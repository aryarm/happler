import warnings
from pathlib import Path
import snakemake.io as io
from snakemake.utils import min_version

##### set minimum snakemake version #####
min_version("7.32.4")


# IMPORT CONFIG VARIABLES
configfile: "config/config.yml"


def check_config(value, default=False, place=config, as_set=False):
    """return true if config value exists and is true"""
    value = place[value] if (value in place and place[value]) else default
    return (set(value) if isinstance(value, list) else {value}) if as_set else value


# handle defaults
config["out"] = check_config("out", "out")
config["min_maf"] = check_config("min_maf", 0)
config["exclude_causal"] = check_config("exclude_causal", False, as_set=True)
# handle locus
if Path(config["locus"]).exists() and Path(config["locus"]).suffix == ".bed":
    with open(Path(config["locus"])) as f:
        locus_file = {
            cols[3]: f"{cols[0]}_{cols[1]}-{cols[2]}"
            for cols in (line.strip().split() for line in f)
        }
    locus = list(locus_file.values())
else:
    locus = config["locus"].replace(":", "_")
# convert the exclude_causal var into a dict for later
exclude_causal = {("in", "ex")[val]: val for val in config["exclude_causal"]}
mode = config["mode"]
# remove any trailing slashes in directories
config["out"] = str(Path(config["out"])) + "/{locus}"


module genotypes:
    snakefile: "rules/genotypes.smk"
    config: config

use rule * from genotypes as genotypes_*
config["gts_str_panel"] = rules.genotypes_subset_str.output.vcf
if check_config("sample_size"):
    sampsize = config["sample_size"]
    config["gts_snp_panel"] = expand(
        rules.genotypes_subset.output.pgen,
        sampsize=sampsize,
        allow_missing=True,
    )[0]
    config["out"] += "/{sampsize}samples"
else:
    config["gts_snp_panel"] = rules.genotypes_subset.input.pgen
config["random"] = False

module simulate:
    snakefile: "rules/simulate.smk"
    config: config
use rule * from simulate as simulate_*

if mode == "ld_range" and config["modes"][mode]["random"]:
    config["random"] = True
    module simulate_random:
        snakefile: "rules/simulate.smk"
        config: config
    use rule * from simulate_random as simulate_random_*
del config["random"]

if mode in ("snp", "hap", "ld_range", "run"):
    happler_config = {
        "pheno": rules.simulate_simphenotype.output.pheno,
        "hap_file": rules.simulate_transform.input.hap,
        "snp_panel": config["gts_snp_panel"],
        "out": config["out"] + "/happler/"+mode+"/{beta}",
        "random": None,
        "covar": check_config("covar", default=[]),
    }
    if mode in ("hap", "ld_range"):
        happler_config["snps"] = []
        if mode == "hap":
            happler_config["snps"] = config["modes"][mode]["alleles"]
        happler_config["causal_gt"] = rules.simulate_transform.output
    if mode == "ld_range":
        happler_config["out"] = config["out"] + "/happler/"+mode+"/ld_{ld}/beta_{beta}/alpha_{alpha}"
    if mode == "run":
        happler_config["hap_file"] = []
        happler_config["pheno"] = lambda wildcards: expand(
            config["modes"][mode]["pheno"],
            gene=wildcards.gene,
        )[0]
        happler_config["out"] = config["out"] + f"/happler/{mode}/" + "{gene}"
elif "str" == mode:
    pass
else:
    raise ValueError("Unsupported operating 'mode' in config")

module happler:
    snakefile: "rules/happler.smk"
    config: happler_config
use rule * from happler as happler_*
merged_happler = rules.happler_merge.output.pgen

if mode == "ld_range" and config["modes"][mode]["random"]:
    happler_config["random"] = rules.simulate_random_transform.output
    happler_config["random_hap"] = rules.simulate_random_transform.input.hap
    happler_config["out"] = config["out"] + "/happler/"+mode+"/random/ld_{ld}/beta_{beta}/alpha_{alpha}"
    module happler_random:
        snakefile: "rules/happler.smk"
        config: happler_config
    use rule * from happler_random as happler_random_*

# if mode in ("hap", "str", "ld_range"):
#     finemappers_config = {
#         "pheno": rules.simulate_simphenotype.output.pheno,
#         "out": config["out"] + "/finemappers/"+mode+"/{beta}",
#         "snp_panel": config["gts_snp_panel"],
#     }
#     if mode in ("hap", "ld_range"):
#         finemappers_config["causal_gt"] = rules.simulate_transform.output.pgen
#         if mode == "ld_range":
#             finemappers_config["out"] = config["out"] + "/finemappers/"+mode+"/ld_{ld}/beta_{beta}/alpha_{alpha}"
#     else:
#         raise ValueError("Not yet implemented operating mode 'str' in config")
#     module finemappers:
#         snakefile: "rules/finemappers.smk"
#         config: finemappers_config
#     use rule * from finemappers as finemappers_*
# else:
#     raise ValueError(f"Unsupported operating mode '{mode}' in config")

plots_config = {
    "out": config["out"] + "/plots",
    "mode": mode,
    "mode_attrs": config["modes"][mode],
    "happler_hap": rules.happler_run.output.hap,
    "causal_hap": rules.simulate_transform.input.hap,
    "snp_panel": config["gts_snp_panel"],
    "happler_metrics": rules.happler_metrics.output.metrics,
}
if mode == "ld_range":
    plots_config["ld_range_checkpoint"] = checkpoints.simulate_create_hap_ld_range

module plots:
    snakefile: "rules/plots.smk"
    config: plots_config
use rule * from plots as plots_*

if mode == "ld_range":
    FINAL_OUTPUT = [rules.plots_params.output.png, rules.plots_metrics.output.png]
elif mode == "run":
    FINAL_OUTPUT = expand(
        rules.happler_manhattan.output.png,
        ex=("in",),
        gene=glob_wildcards(Path(config["modes"][mode]["pheno"])).gene,
        allow_missing=True,
    )
else:
    FINAL_OUTPUT = expand(
        [
            rules.happler_tree.output.png,
            rules.happler_manhattan.output.png,
            # rules.finemappers_results.output.susie_pdf,
            rules.happler_results.output.susie_pdf,
            rules.plots_params.output.png,
        ],
        ex=(("in",) if mode == "hap" else ("ex", "in")),
        beta=config["modes"]["hap"]["beta"],
        allow_missing=True,
    )

rule all:
    input:
       expand(
            FINAL_OUTPUT,
            locus=locus,
            sampsize=config["sample_size"],
        ) if check_config("sample_size") else expand(FINAL_OUTPUT, locus=locus)
    default_target: True
